// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEvents = `-- name: CountEvents :one
SELECT count(*) FROM events
`

func (q *Queries) CountEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTempEvents = `-- name: CountTempEvents :one
SELECT count(*) FROM _temp_events
`

func (q *Queries) CountTempEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTempEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createScan = `-- name: CreateScan :one
INSERT INTO scans (radius, from_date, to_date, events_count, address, lat, long) VALUES ($1,$2,$3,$4,$5,$6,$7) RETURNING id, created_at, radius, from_date, to_date, events_count, address, point, lat, long
`

type CreateScanParams struct {
	Radius      int32              `json:"radius"`
	FromDate    pgtype.Timestamptz `json:"from_date"`
	ToDate      pgtype.Timestamptz `json:"to_date"`
	EventsCount int32              `json:"events_count"`
	Address     string             `json:"address"`
	Lat         float64            `json:"lat"`
	Long        float64            `json:"long"`
}

func (q *Queries) CreateScan(ctx context.Context, arg CreateScanParams) (Scan, error) {
	row := q.db.QueryRow(ctx, createScan,
		arg.Radius,
		arg.FromDate,
		arg.ToDate,
		arg.EventsCount,
		arg.Address,
		arg.Lat,
		arg.Long,
	)
	var i Scan
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Radius,
		&i.FromDate,
		&i.ToDate,
		&i.EventsCount,
		&i.Address,
		&i.Point,
		&i.Lat,
		&i.Long,
	)
	return i, err
}

type CreateTempEventsParams struct {
	OccurAt    pgtype.Timestamptz `json:"occur_at"`
	ExternalID string             `json:"external_id"`
	Details    []byte             `json:"details"`
	Lat        float64            `json:"lat"`
	Long       float64            `json:"long"`
}

const createTempEventsTable = `-- name: CreateTempEventsTable :exec


CREATE TEMPORARY TABLE _temp_events (LIKE events INCLUDING ALL) ON COMMIT DROP
`

// =========================================
// events
func (q *Queries) CreateTempEventsTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempEventsTable)
	return err
}

const moveFromTempEventsToEvents = `-- name: MoveFromTempEventsToEvents :exec
INSERT INTO events (
    occur_at,
    external_id,
    details,
    lat,
    long
)
SELECT
    occur_at,
    external_id,
    details,
    lat,
    long
FROM _temp_events
ON CONFLICT (external_id) DO NOTHING
`

func (q *Queries) MoveFromTempEventsToEvents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, moveFromTempEventsToEvents)
	return err
}
